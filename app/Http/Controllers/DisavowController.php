<?php

namespace App\Http\Controllers;

use App\Models\Domain;
use App\Models\DomainBacklinkRun;
use App\Models\DomainBacklink;
use App\Models\DisavowFile;
use App\Models\DisavowEntry;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Response;
use Inertia\Inertia;

class DisavowController extends Controller
{
    /**
     * List disavow files for a domain
     */
    public function index(Domain $domain)
    {
        if ($domain->user_id !== Auth::id()) {
            abort(403);
        }

        $files = DisavowFile::where('domain_id', $domain->id)
            ->where('user_id', Auth::id())
            ->withCount('entries')
            ->latest()
            ->get();

        $latestRun = DomainBacklinkRun::where('domain_id', $domain->id)
            ->where('user_id', Auth::id())
            ->where('status', DomainBacklinkRun::STATUS_COMPLETED)
            ->latest()
            ->first();

        $pendingCount = 0;
        if ($latestRun) {
            $pendingCount = DomainBacklink::where('run_id', $latestRun->id)
                ->where('action_status', DomainBacklink::ACTION_DISAVOW)
                ->count();
        }

        return Inertia::render('Disavow/Index', [
            'domain' => $domain,
            'files' => $files,
            'latestRun' => $latestRun,
            'pendingCount' => $pendingCount,
        ]);
    }

    /**
     * Generate a new disavow file from latest run
     */
    public function generate(Request $request, Domain $domain)
    {
        if ($domain->user_id !== Auth::id()) {
            abort(403);
        }

        $validated = $request->validate([
            'notes' => 'nullable|string|max:1000',
        ]);

        $latestRun = DomainBacklinkRun::where('domain_id', $domain->id)
            ->where('user_id', Auth::id())
            ->where('status', DomainBacklinkRun::STATUS_COMPLETED)
            ->latest()
            ->first();

        if (!$latestRun) {
            return back()->withErrors(['disavow' => 'No completed backlink run found.']);
        }

        $domains = DomainBacklink::where('run_id', $latestRun->id)
            ->where('action_status', DomainBacklink::ACTION_DISAVOW)
            ->pluck('source_domain')
            ->unique()
            ->filter()
            ->values();

        if ($domains->isEmpty()) {
            return back()->withErrors(['disavow' => 'No backlinks marked for disavow.']);
        }

        $nextVersion = (int) (DisavowFile::where('domain_id', $domain->id)->max('version') ?? 0) + 1;

        $lines = [];
        $lines[] = '# Disavow file generated by Backlink Pro';
        $lines[] = '# Domain: ' . $domain->host;
        $lines[] = '# Generated: ' . now()->toDateTimeString();
        $lines[] = '';

        foreach ($domains as $refDomain) {
            $lines[] = 'domain:' . $refDomain;
        }

        $fileText = implode("\n", $lines);

        $file = DisavowFile::create([
            'domain_id' => $domain->id,
            'user_id' => Auth::id(),
            'version' => $nextVersion,
            'status' => DisavowFile::STATUS_DRAFT,
            'notes' => $validated['notes'] ?? null,
            'file_text' => $fileText,
            'generated_at' => now(),
        ]);

        foreach ($domains as $refDomain) {
            DisavowEntry::create([
                'disavow_file_id' => $file->id,
                'entry_type' => DisavowEntry::ENTRY_TYPE_DOMAIN,
                'value' => $refDomain,
                'value_hash' => DisavowEntry::generateHash($refDomain),
                'reason' => 'Marked for disavow in quality review',
            ]);
        }

        return back()->with('success', 'Disavow file generated.');
    }

    /**
     * Download disavow file
     */
    public function export(Domain $domain, DisavowFile $file)
    {
        if ($domain->user_id !== Auth::id() || $file->domain_id !== $domain->id) {
            abort(403);
        }

        $filename = "disavow-{$domain->host}-v{$file->version}.txt";

        return Response::make($file->file_text ?? '', 200, [
            'Content-Type' => 'text/plain',
            'Content-Disposition' => "attachment; filename=\"{$filename}\"",
        ]);
    }
}
